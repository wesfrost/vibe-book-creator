\nimport { callGemini } from \'./geminiService\';\nimport { ORCHESTRATOR_PERSONA } from \'./personas/orchestrator\';\nimport { STRATEGIST_PERSONA } from \'./personas/strategist\';\nimport { WRITER_PERSONA } from \'./personas/writer\';\nimport { ChatMessage, BookState } from \'../types\';\nimport { Type } from \"@google/genai\";\n\n// --- Schema Definitions (Corrected and complete) ---\nconst getResponseSchemaForOptions = (itemDescription: string) => ({\n    type: Type.OBJECT,\n    properties: {\n        message: { type: Type.STRING },\n        options: {\n            type: Type.ARRAY,\n            items: {\n                type: Type.OBJECT,\n                properties: {\n                    title: { type: Type.STRING },\n                    description: { type: Type.STRING },\n                    rationale: { type: Type.STRING }\n                },\n                required: [\'title\', \'description\', \'rationale\']\n            }\n        }\n    },\n    required: [\"message\", \"options\"],\n});\n\nconst getResponseSchemaForOutline = () => ({\n    type: Type.OBJECT,\n    properties: {\n        message: { type: Type.STRING },\n        outline: {\n            type: Type.ARRAY,\n            items: {\n                type: Type.OBJECT,\n                properties: {\n                    chapterTitle: { type: Type.STRING },\n                    chapterDescription: { type: Type.STRING }\n                },\n                required: [\'chapterTitle\', \'chapterDescription\']\n            }\n        }\n    },\n    required: [\"message\", \"outline\"],\n});\n\nconst getResponseSchemaForChapterDraft = () => ({\n    type: Type.OBJECT,\n    properties: {\n        postChapterMessage: { type: Type.STRING },\n        chapterTitle: { type: Type.STRING },\n        chapterContent: { type: Type.STRING }\n    },\n    required: [\"postChapterMessage\", \"chapterTitle\", \"chapterContent\"],\n});\n\n// --- Main Orchestration Logic ---\nexport const processStep = async (\n    history: ChatMessage[],\n    step: string,\n    bookState: BookState,\n    modelId: string\n): Promise<any> => {\n\n    const persona = getPersonaForStep(step);\n    const responseSchema = getResponseSchemaForSchemaType(step);\n    let applyGoldenRule = shouldApplyGoldenRule(step); // Determine if Golden Rule applies\n    \n    // Construct prompt and explicitly ask for JSON in markdown fences if a schema is present.\n    let prompt = constructPrompt(history, step, bookState, applyGoldenRule);\n    if (responseSchema && responseSchema.type === Type.OBJECT) {\n        prompt += `\\n\\n**IMPORTANT:** Always wrap your JSON output in a markdown code block, like this: \`\`\`json { ... } \`\`\``;\n    }\n\n    try {\n        const response = await callGemini({\n            systemInstruction: persona,\n            prompt,\n            responseSchema: responseSchema,\n            modelId\n        });\n        return response;\n    } catch (error) {\n        console.error(\"Error processing step:\", error);\n        return { message: \"Oh no! My creative circuits are buzzing with errors. Let\'s try that again! ðŸ¤–âš¡ï¸\" };\n    }\n};\n\n// Helper to determine the persona based on the current step\nconst getPersonaForStep = (step: string): string => {\n    if ([\"Book Format Selected\", \"Genre Defined\", \"Working Title Defined\", \"Core Idea Locked In\", \"Vibe Defined\", \"Target Audience Identified\", \"Main Storyline Solidified\", \"Key Characters Defined\", \"Number of Chapters Defined\", \"Pacing Strategy Agreed\"].includes(step)) return STRATEGIST_PERSONA;\n    if (step === \"Chapter Outline\" || step.includes(\"Drafted\")) return WRITER_PERSONA;\n    return ORCHESTRATOR_PERSONA; // Default persona\n};\n\n// Helper to determine which schema to use for the response\nconst getResponseSchemaForSchemaType = (step: string): any => {\n    if ([\"Book Format Selected\", \"Genre Defined\", \"Working Title Defined\", \"Core Idea Locked In\", \"Vibe Defined\", \"Target Audience Identified\", \"Main Storyline Solidified\", \"Key Characters Defined\", \"Number of Chapters Defined\", \"Pacing Strategy Agreed\"].includes(step)) return getResponseSchemaForOptions(step);\n    if (step === \"Chapter Outline\") return getResponseSchemaForOutline();\n    if (step.includes(\"Drafted\")) return getResponseSchemaForChapterDraft();\n    return { type: Type.OBJECT, properties: { message: { type: Type.STRING } }, required: [\"message\"] }; // Default schema\n};\n\n// Helper to apply the Golden Rule based on the step\nconst shouldApplyGoldenRule = (step: string): boolean => {\n    return [\"Book Format Selected\", \"Genre Defined\", \"Working Title Defined\", \"Core Idea Locked In\", \"Vibe Defined\", \"Target Audience Identified\", \"Main Storyline Solidified\", \"Key Characters Defined\", \"Number of Chapters Defined\", \"Pacing Strategy Agreed\"].includes(step);\n};\n\nfunction constructPrompt(history: ChatMessage[], currentStep: string, bookState: BookState, applyGoldenRule: boolean): string {\n    const historyString = history.slice(-5).map(m => `${m.sender}: ${m.text}`).join(\'\\n\');\n    let taskInstruction = `Based on all the above, perform your expert function for the author\'s current task.`;\n    if(currentStep === \"Chapter Outline\") {\n        taskInstruction = `You are a master storyteller and bestselling author. Based on all the book\'s details (especially the genre, vibe, and storyline), generate a complete, chapter-by-chapter outline for all ${bookState.chapterCount} chapters. Each chapter in the outline should have a compelling title and a detailed, paragraph-long description of its key events, character arcs, and plot points. The full outline should follow a proven story structure (like the three-act structure) to maximize reader engagement.`;\n    }\n    let basePrompt = `\nHere is the recent conversation history:\n${historyString}\nHere is the current state of the book we are writing:\n${JSON.stringify(bookState, null, 2)}\nThe author\'s current task is: **${currentStep}**.\n${taskInstruction}\n`;\n    if (applyGoldenRule) {\n        const goldenRule = \"Your primary goal is to provide actionable, structured \'options\' for the user to select. If the user provides feedback, use it to refine and generate a *better* set of options for the same step. Always present the user with choices.\";\n        basePrompt += `\\n\\n**Golden Rule:** ${goldenRule}`;\n    }\n    return basePrompt;\n}\n