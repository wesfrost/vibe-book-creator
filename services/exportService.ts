
import { BookState } from '../types';
import JSZip from 'jszip';
import { Document, Packer, Paragraph, TextRun, AlignmentType, PageBreak, Header, Footer, PageNumber } from 'docx';

// A new helper function to handle downloads in sandboxed environments
const triggerDownload = (blob: Blob, fileName: string) => {
    // Create a Blob URL
    const url = window.URL.createObjectURL(blob);
    
    // Create a temporary anchor tag
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    
    // Append to the body, click, and then remove
    document.body.appendChild(a);
    a.click();
    
    // Cleanup
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
};

export const generateKDPPackage = async (bookState: BookState): Promise<void> => {
    const zip = new JSZip();

    const doc = new Document({
        sections: [{
            ...generateDocxProperties(bookState),
            children: generateDocumentContent(bookState),
        }],
    });

    const docBlob = await Packer.toBlob(doc);
    zip.file(`${bookState.title || 'manuscript'}.docx`, docBlob);

    const metadata = {
        title: bookState.title,
        author: "Generated by Vibe Book Creator",
        blurb: bookState.marketing?.blurb,
        keywords: bookState.marketing?.keywords,
        categories: bookState.marketing?.categories
    };
    zip.file("metadata.json", JSON.stringify(metadata, null, 2));

    const zipBlob = await zip.generateAsync({ type: "blob" });
    triggerDownload(zipBlob, `${bookState.title?.replace(/\s+/g, '_') || 'book'}_KDP.zip`);
};

const generateDocumentContent = (bookState: BookState): Paragraph[] => {
    const paragraphs: Paragraph[] = [];

    // Title Page
    if (bookState.title) {
        paragraphs.push(new Paragraph({
            children: [new TextRun({ text: bookState.title, bold: true, size: 48 })],
            alignment: AlignmentType.CENTER,
            spacing: { before: 2000, after: 2000 },
        }));
        paragraphs.push(new Paragraph({ children: [new PageBreak()] }));
    }

    // Chapters
    if (bookState.chapters) {
        bookState.chapters.forEach((chapter, index) => {
            paragraphs.push(new Paragraph({
                children: [new TextRun({ text: chapter.title, bold: true, size: 36 })],
                alignment: AlignmentType.CENTER,
                spacing: { after: 200 },
            }));

            if (typeof chapter.content === 'string') {
                const contentParagraphs = chapter.content.split('\n').filter(line => line.trim() !== '');
                contentParagraphs.forEach(line => {
                    paragraphs.push(new Paragraph({ 
                        text: line, 
                        indent: { firstLine: "0.5in" },
                        spacing: { after: 0 }
                    }));
                });
            }
            if (index < bookState.chapters.length - 1) {
                paragraphs.push(new Paragraph({ children: [new PageBreak()] }));
            }
        });
    }
    return paragraphs;
};

const generateDocxProperties = (bookState: BookState) => ({
    headers: {
        default: new Header({
            children: [
                new Paragraph({
                    children: [new TextRun(bookState.title || 'Your Book Title')],
                    alignment: AlignmentType.RIGHT,
                }),
            ],
        }),
    },
    footers: {
        default: new Footer({
            children: [
                new Paragraph({
                    children: [new TextRun({ children: [PageNumber.CURRENT] })],
                    alignment: AlignmentType.CENTER,
                }),
            ],
        }),
    },
});

export const exportAsDocx = async (bookState: BookState) => {
    if (!bookState.title) {
        console.error("Book title is not set. Cannot export.");
        return;
    }
    const doc = new Document({
        sections: [{
            ...generateDocxProperties(bookState),
            children: generateDocumentContent(bookState),
        }],
    });

    const blob = await Packer.toBlob(doc);
    triggerDownload(blob, `${bookState.title.replace(/\s+/g, '_')}.docx`);
};

export const exportAsMarkdown = (bookState: BookState) => {
    if (!bookState.title) {
        console.error("Book title is not set. Cannot export.");
        return;
    }

    let markdownContent = `# ${bookState.title}\n\n`;

    if (bookState.globalOutline) {
        markdownContent += `## Outline\n\n${bookState.globalOutline}\n\n`;
    }

    if (bookState.chapters) {
        bookState.chapters.forEach((chapter) => {
            markdownContent += `## ${chapter.title}\n\n`;
            markdownContent += `${chapter.content}\n\n`;
        });
    }

    const blob = new Blob([markdownContent], { type: 'text/markdown;charset=utf-8' });
    triggerDownload(blob, `${bookState.title.replace(/\s+/g, '_')}.md`);
};
